import * as PIXI from "pixi.js";
import { parseTagsNew, removeTags } from "./tags";
import {
  RichTextOptions,
  TextStyleSet,
  TextStyleExtended,
  TagWithAttributes,
  AttributesList,
  ImageMap,
  IMG_SRC_PROPERTY,
  IMG_DISPLAY_PROPERTY,
  FinalToken,
  isSpriteToken,
  TextFinalToken,
  isTextToken,
  isNotWhitespaceToken,
  SpriteFinalToken,
} from "./types";
import { calculateFinalTokens } from "./layout";
import {
  combineAllStyles,
  getStyleForTag as getStyleForTagExt,
  mapTagsToStyles,
} from "./style";
import { addChildrenToContainer } from "./pixiUtils";
import { pluck } from "./functionalUtils";

const DEFAULT_STYLE: TextStyleExtended = {
  align: "left",
  valign: "baseline",
  [IMG_DISPLAY_PROPERTY]: "inline",
  wordWrap: true,
  wordWrapWidth: 500,
};

const DEFAULT_OPTIONS: RichTextOptions = {
  debug: false,
  debugConsole: false,
  splitStyle: "words",
  imgMap: {},
  skipUpdates: false,
  skipDraw: false,
  drawWhitespace: false,
};

const DEBUG = {
  WORD_STROKE_COLOR: 0x00ff00,
  WORD_FILL_COLOR: 0xff00ff,
  BASELINE_COLOR: 0x0033cc,
  LINE_COLOR: 0xffff00,
  OUTLINE_COLOR: 0xffcccc,
  OUTLINE_SHADOW_COLOR: 0x000000,
  TEXT_STYLE: {
    fontFamily: "courier",
    fontSize: 10,
    fill: 0xffffff,
    dropShadow: true,
  },
};

export default class RichText extends PIXI.Sprite {
  // todo: allow setting options after the constructor is called. Make sure to call update()
  /** Settings for the RichText component. */
  private _options: RichTextOptions;
  public get options(): RichTextOptions {
    return this._options;
  }

  private _needsUpdate = true;
  public get needsUpdate(): boolean {
    return this._needsUpdate;
  }
  private _needsDraw = true;
  public get needsDraw(): boolean {
    return this._needsDraw;
  }

  private _tokens: FinalToken[] = [];
  /**
   * Tokens representing parsed out and styled tagged text. This is generated by update.
   * They contain all the information needed to render the text fields and other children in your component.
   */
  public get tokens(): FinalToken[] {
    return this._tokens;
  }

  private _text = "";
  public get text(): string {
    return this._text;
  }

  /**
   * Alternative implicit setter for text. Always uses default for skipUpdate.
   */
  public set text(text: string) {
    this.setText(text);
  }

  /**
   * Setter for text that allows you to override the default for skipping the update.
   * @param text Text to add to component with (optional) tags.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the text.
   * When true, setText() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setText(text: string, skipUpdate?: boolean): void {
    if (text === this._text && this._needsUpdate === false) {
      return;
    }
    this._text = text;
    this._needsUpdate = true;
    this.updateIfShould(skipUpdate);
  }

  /**
   * Returns the text content with all tags stripped out.
   */
  public get untaggedText(): string {
    return removeTags(this.text);
  }

  private _tagStyles: TextStyleSet = {};
  public get tagStyles(): TextStyleSet {
    return this._tagStyles;
  }

  /**
   * Alternative implicit setter for tagStyles. Always uses default for skipUpdate.
   */
  public set tagStyles(styles: TextStyleSet) {
    this.setTagStyles(styles);
  }

  /**
   * Setter for tagStyles.
   * @param styles Object with strings for keys representing tag names, mapped to style objects.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, setTagStyles() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setTagStyles(styles: TextStyleSet, skipUpdate?: boolean): void {
    Object.entries(styles).forEach(([tag, style]) =>
      this.setStyleForTag(tag, style, true)
    );
    // TODO: add a way to test for identical styles to prevent unnecessary updates.
    this._needsUpdate = true;
    this.updateIfShould(skipUpdate);
  }

  public getStyleForTag(
    tag: string,
    attributes: AttributesList = {}
  ): TextStyleExtended | undefined {
    return getStyleForTagExt(tag, this.tagStyles, attributes);
  }

  public getStyleForTags(tags: TagWithAttributes[]): TextStyleExtended {
    const styles = tags.map(({ tagName, attributes }) =>
      this.getStyleForTag(tagName, attributes)
    );
    return combineAllStyles(styles);
  }

  /**
   * Set a style to be used by a single tag.
   * @param tag Name of the tag to set style for
   * @param styles Style object to assign to the tag.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, setStyleForTag() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setStyleForTag(
    tag: string,
    styles: TextStyleExtended,
    skipUpdate?: boolean
  ): boolean {
    this.tagStyles[tag] = styles;

    // TODO: warn user when trying to set styles on a tag that doesn't support it...
    // e.g. wordWrapWidth on a styel other than default.

    // Override some settings on default styles.
    if (tag === "default" && this.defaultStyle[IMG_SRC_PROPERTY]) {
      // prevents accidentally setting all text to images.
      console.error(
        `Style "${IMG_SRC_PROPERTY}" can not be set on the "default" style because it will add images to EVERY tag!`
      );
      this.defaultStyle[IMG_SRC_PROPERTY] = undefined;
    }
    // TODO: add a way to test for identical styles to prevent unnecessary updates.
    this._needsUpdate = true;
    this.updateIfShould(skipUpdate);

    return true;
  }
  /**
   * Removes a style associated with a tag. Note, inline attributes are not affected.
   * @param tag Name of the tag to delete the style of.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, removeStylesForTag() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public removeStylesForTag(tag: string, skipUpdate?: boolean): boolean {
    if (tag in this.tagStyles) {
      delete this.tagStyles[tag];

      this._needsUpdate = true;
      this.updateIfShould(skipUpdate);

      return true;
    }
    return false;
  }

  public get defaultStyle(): TextStyleExtended {
    return this.tagStyles?.default;
  }
  /**
   * Alternative implicit setter for defaultStyle. Always uses default for skipUpdate.
   */
  public set defaultStyle(defaultStyles: TextStyleExtended) {
    this.setDefaultStyle(defaultStyles);
  }
  /**
   * Setter for default styles. A shortcut to this.setStyleForTag("default",...)
   * @param styles A style object to use as the default styles for all text in the component.
   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.
   * When true, setDefaultStyle() never updates even if default is false, and vice versa.
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public setDefaultStyle(
    defaultStyles: TextStyleExtended,
    skipUpdate?: boolean
  ): void {
    this.setStyleForTag("default", defaultStyles, skipUpdate);
  }

  // References to internal elements.
  private _textFields: PIXI.Text[] = [];
  public get textFields(): PIXI.Text[] {
    return this._textFields;
  }
  private _sprites: PIXI.Sprite[] = [];
  public get sprites(): PIXI.Sprite[] {
    return this._sprites;
  }
  public get spriteTemplates(): PIXI.Sprite[] {
    return Object.values(this.options?.imgMap ?? {});
  }
  private _debugGraphics: PIXI.Graphics | null = null;

  // Containers for children
  private _textContainer: PIXI.Container;
  public get textContainer(): PIXI.Container {
    return this._textContainer;
  }
  private _spriteContainer: PIXI.Container;
  public get spriteContainer(): PIXI.Container {
    return this._spriteContainer;
  }
  private _debugContainer: PIXI.Container;
  public get debugContainer(): PIXI.Container {
    return this._debugContainer;
  }

  constructor(
    text = "",
    tagStyles: TextStyleSet = {},
    options: RichTextOptions = {},
    texture?: PIXI.Texture
  ) {
    super(texture);

    this._textContainer = new PIXI.Container();
    this._spriteContainer = new PIXI.Container();
    this._debugContainer = new PIXI.Container();

    this.addChild(this._textContainer);
    this.addChild(this._spriteContainer);
    this.addChild(this._debugContainer);

    this.resetChildren();

    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
    this._options = mergedOptions;

    tagStyles = { default: {}, ...tagStyles };
    const mergedDefaultStyles = { ...DEFAULT_STYLE, ...tagStyles.default };
    tagStyles.default = mergedDefaultStyles;
    this.tagStyles = tagStyles;

    if (this.options.imgMap) {
      this.registerImageMap(this.options.imgMap);
    }

    this.text = text;
  }

  /**
   * Removes all PIXI children from this component's containers.
   * Deletes references to sprites and text fields.
   */
  private resetChildren() {
    this._debugContainer.removeChildren();
    this._textContainer.removeChildren();
    this._spriteContainer.removeChildren();

    this._textFields = [];
    this._sprites = [];
  }

  /**
   * Creates associations between string-based keys like "img" and
   * image Sprite objects which are included in the text.
   * @param imgMap
   */
  private registerImageMap(imgMap: ImageMap) {
    Object.entries(imgMap).forEach(([key, sprite]) => {
      // Listen for changes to sprites (e.g. when they load.)
      const texture = sprite.texture;
      if (texture !== undefined) {
        texture.baseTexture.addListener("update", () => this.updateIfShould());
      }

      // create a style for each of these by default.
      const existingStyle = this.getStyleForTag(key) ?? {};
      const style = { [IMG_SRC_PROPERTY]: key, ...existingStyle };
      this.setStyleForTag(key, style);
    });
  }

  /**
   * Determines whether to call update based on the parameter and the options set then calls it or sets needsUpdate to true.
   * @param forcedSkipUpdate This is the parameter provided to some functions that allow you to skip the update.
   * It's factored in along with the defaults to figure out what to do.
   */
  private updateIfShould(forcedSkipUpdate?: boolean): void {
    if (forcedSkipUpdate === false) {
      this.update();
    } else if (
      forcedSkipUpdate === undefined &&
      this.options.skipUpdates === false
    ) {
      this.update();
    }
  }

  /**
   * Calculates styles, positioning, etc. of the text and styles and creates a
   * set of objects that represent where each portion of text and image should
   * be drawn.
   * @param skipDraw *For advanced users* overrides default for redrawing the styles.
   * When true, update() will skip the call to draw() (even if the default is false).
   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting
   * is provided in this.options.
   */
  public update(skipDraw?: boolean): FinalToken[] {
    // Determine default style properties
    const tagStyles = this.tagStyles;
    const { imgMap, splitStyle } = this.options;
    // const wordWrapWidth = this.defaultStyle.wordWrap
    //   ? this.defaultStyle.wordWrapWidth
    //   : Number.POSITIVE_INFINITY;
    // const align = this.defaultStyle.align;
    // const lineSpacing = this.defaultStyle.lineSpacing;

    // Pre-process text.
    // Parse tags in the text.
    const tagTokensNew = parseTagsNew(this.text, Object.keys(this.tagStyles));
    // Assign styles to each segment.
    const styledTokens = mapTagsToStyles(tagTokensNew, tagStyles, imgMap);
    styledTokens;
    // Measure font for each style
    // Measure each segment
    // Create the text segments, position and add them. (draw)
    const newFinalTokens = calculateFinalTokens(styledTokens, splitStyle);

    this._tokens = newFinalTokens;
    this._needsDraw = true;

    // Wait one frame to draw so that this doesn't happen multiple times in one frame.
    // if (this.animationRequest) {
    //   window.cancelAnimationFrame(this.animationRequest);
    // }
    // this.animationRequest = window.requestAnimationFrame(

    this.drawIfShould(skipDraw);

    if (this.options.debugConsole) {
      console.log(this.toDebugString());
    }

    this._needsUpdate = false;

    return newFinalTokens;
  }

  /**
   * Determines whether to call draw() based on the parameter and the options set then calls it or sets needsDraw to true.
   * @param forcedSkipDraw This is the parameter provided to some functions that allow you to skip the update.
   * It's factored in along with the defaults to figure out what to do.
   */
  private drawIfShould(forcedSkipDraw?: boolean) {
    if (forcedSkipDraw === false) {
      this.draw();
    } else if (
      forcedSkipDraw === undefined &&
      this.options.skipDraw === false
    ) {
      this.draw();
    }
  }

  public draw(): void {
    this.resetChildren();
    const { drawWhitespace } = this.options;
    const tokens = drawWhitespace
      ? this._tokens
      : this._tokens.filter(isNotWhitespaceToken);

    const textFields = this.createTextFieldsForTokens(tokens);
    const sprites = this.getSpritesFromTokens(tokens);
    this.positionDisplayObjects(textFields, tokens);

    addChildrenToContainer(textFields, this.textContainer);
    this._textFields = textFields;

    addChildrenToContainer(sprites, this.spriteContainer);
    this._sprites = sprites;

    if (this.options.debug) {
      this.drawDebug(tokens);
    }
    this._needsDraw = false;
  }

  private createTextFieldsForTokens(tokens: FinalToken[]): PIXI.Text[] {
    return tokens
      .filter(isTextToken)
      .map((t) => this.createTextFieldForToken(t));
  }

  private getSpritesFromTokens(tokens: FinalToken[]): PIXI.Sprite[] {
    const spriteTokens: SpriteFinalToken[] = tokens.filter(isSpriteToken);
    return pluck<PIXI.Sprite, SpriteFinalToken>("content")(spriteTokens);
  }

  private createTextFieldForToken(token: TextFinalToken): PIXI.Text {
    return new PIXI.Text(token.content, token.style);
  }

  private positionDisplayObjects(
    textFields: PIXI.DisplayObject[],
    tokens: FinalToken[]
  ): void {
    for (let i = 0; i < textFields.length; i++) {
      const d = textFields[i];
      const { bounds: m, content } = tokens[i];
      d.x = m.x;
      d.y = m.y;

      if (content instanceof PIXI.Sprite) {
        const sprite = content;
        sprite.x = m.x;
        sprite.y = m.y;
      }
    }
  }

  /**
   * Converts the text properties from this.tokens into a human readable string.
   * This is automatically logged to the console on update when debug option is set to true.
   */
  public toDebugString(): string {
    let s = this.untaggedText + "\n  ";
    if (this._tokens !== undefined) {
      s += this._tokens
        .map((token, tokenNumber) => {
          const nl = "\n    ";
          let s = `  "${token.content}":`;
          // s += `${nl}line: ${lineNumber},
          s += `${nl}word: ${tokenNumber}`;
          s += `${nl}tags: ${
            token.tags.length === 0
              ? "<none>"
              : token.tags
                  .split(",")
                  .map((tag) => `<${tag}>`)
                  .join(", ")
          }`;
          s += `${nl}style: ${Object.entries(token.style)
            .map((e) => e.join(":"))
            .join("; ")}`;
          s += `${nl}size: x:${token.bounds.x} y:${token.bounds.y} width:${token.bounds.width} height:${token.bounds.height}`;
          s += `${nl}font: fontSize:${token.fontProperties.fontSize} ascent:${token.fontProperties.ascent} descent:${token.fontProperties.descent}`;
          return s;
        })
        .join("\n");
    }
    return s;
  }

  public drawDebug(tokens: FinalToken[]): void {
    this._debugGraphics = new PIXI.Graphics();
    this.debugContainer.addChild(this._debugGraphics);

    const g = this._debugGraphics;
    g.clear();

    g.lineStyle(2, DEBUG.OUTLINE_COLOR, 1);
    g.beginFill();
    g.drawRect(1, 1, this.width, this.height);
    g.endFill();

    g.lineStyle(2, DEBUG.OUTLINE_SHADOW_COLOR, 1);
    g.beginFill();
    g.drawRect(0, 0, this.width - 1, this.height - 1);
    g.endFill();

    // for (const line of tokens) {
    let lineY = Number.POSITIVE_INFINITY;
    let lineHeight = 0;
    for (const token of tokens) {
      const { ascent } = token.fontProperties;
      const { x, y, width, height } = token.bounds;

      lineHeight = Math.max(lineHeight, height);
      lineY = Math.min(lineY, y);

      g.lineStyle(1, DEBUG.WORD_STROKE_COLOR, 1);
      g.beginFill(DEBUG.WORD_FILL_COLOR, 0.2);
      g.drawRect(x, y, width, height);
      g.endFill();

      g.lineStyle(1, DEBUG.BASELINE_COLOR, 1);
      g.beginFill();
      g.drawRect(x, y + ascent, width, 1);
      g.endFill();

      if (isTextToken(token)) {
        const info = new PIXI.Text(token.tags, DEBUG.TEXT_STYLE);
        info.x = x + 1;
        info.y = y + 1;
        this.debugContainer.addChild(info);
      }
    }
    if (this.defaultStyle.wordWrap) {
      const w = this.defaultStyle.wordWrapWidth ?? this.width;
      g.lineStyle(0.5, DEBUG.LINE_COLOR, 0.2);
      g.drawRect(0, lineY, w, lineHeight);
      g.endFill();
    }
    // }
  }
}
