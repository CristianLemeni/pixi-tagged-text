<!DOCTYPE html>
<html>
  <head>
    <title>pixi-tagged-text Demo</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="style.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap"
      rel="stylesheet"
    />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.2.2/browser/pixi.min.js"></script>

    <!-- TaggedText -->
    <script src="../dist/pixi-tagged-text.umd.js"></script>
  </head>

  <body>
    <h1>pixi-tagged-text Demo</h1>
    <main>
      <div class="example">
        <div class="code">
          <pre><code class="js"></code></pre>
        </div>

        <div class="pixi" id="basic">
          <script>
            ///////// CONFIG TESTS /////////
            const TEST_TT = true;
            const TEST_PLAIN_TEXT = true;
            const TEST_TEXTURE_CACHE = true;
            const TEST_ICON = true;

            const SET_SIZE = 25;
            const INTERVAL = 250;
            const LIMIT = 5000;
            ///////////////////////////////

            PIXI.settings.RESOLUTION = 2;
            const app = new PIXI.Application({
              width: 600,
              height: 600,
              backgroundColor: 0x333333,
            });
            document.getElementById("basic").appendChild(app.view);

            let tt;
            let plainText;
            const iconImage = PIXI.Sprite.from("./icon.png");
            const style = {
              fontSize: 40,
              textDecoration: "underline",
              wordWrap: true,
              wordWrapWidth: 400,
              fill: 0xffffff,
            };
            const options = {
              imgMap: { icon: iconImage },
              debug: false,
              drawWhitespace: false,
            };

            const text =
              "Hello my baby, hello my honey, hello my ragtime gal!\n" +
              (TEST_ICON ? `<icon />` : ``);
            const styleSet = {
              default: style,
            };

            const makeTaggedText = (total) => {
              try {
                tt = new TaggedText(text + " " + total, styleSet, options);
                tt.x = 50;
                tt.y = 50;
                app.stage.addChild(tt);
              } catch (error) {
                console.warn("Failed to create TaggedText");
                console.error(error);
              }
            };

            const destroyTaggedText = () => {
              if (tt && tt.destroyed === false) {
                app.stage.removeChild(tt);
                // tt.destroyImgMap();
                tt.destroy();
                tt = null;
              }
            };

            const makePlainText = () => {
              plainText = new PIXI.Text(text + " " + total, style);
              plainText.x = 50;
              plainText.y = 350;
              app.stage.addChild(plainText);
            };

            const destroyPlainText = () => {
              app.stage.removeChild(plainText);
              plainText.destroy();
              plainText = null;
            };

            let total = 0;
            const firstHeapSize =
              window.performance.memory.usedJSHeapSize / 1024 / 1024;
            let lastHeapSize = firstHeapSize;
            const firstTextureCacheSize = Object.keys(
              PIXI.utils.TextureCache
            ).length;
            let lastTextureCacheSize = firstTextureCacheSize;

            const runTest = () => {
              let i = SET_SIZE;
              while (i > 0) {
                total += 1;

                if (TEST_TT) {
                  if (tt) {
                    destroyTaggedText();
                  }
                  makeTaggedText(total);
                }

                if (TEST_PLAIN_TEXT) {
                  if (plainText) {
                    destroyPlainText();
                  }
                  makePlainText(total);
                }

                i--;
              }

              const heapSize = Math.ceil(
                window.performance.memory.usedJSHeapSize / 1024 / 1024
              );
              console.log(
                `iterations:${total} • Heap size: ${heapSize}MB • change: ${
                  heapSize - lastHeapSize
                }`
              );
              if (TEST_TEXTURE_CACHE) {
                const textureCacheSize = Object.keys(
                  PIXI.utils.TextureCache
                ).length;
                console.log(
                  `iterations:${total} • TextureCache size: ${textureCacheSize} • change: ${
                    textureCacheSize - lastTextureCacheSize
                  }`
                );
                lastTextureCacheSize = textureCacheSize;
              }
              if (total >= LIMIT) {
                clearInterval(loop);
                const total = (heapSize - firstHeapSize).toFixed(2);
                const each = (
                  ((heapSize - firstHeapSize) * 1024) /
                  LIMIT
                ).toFixed(2);
                console.log(`Total gain: ${total}MB (${each}KB/iteration)`);
              }
              lastHeapSize = heapSize;
            };
            var loop = setInterval(runTest, INTERVAL);
          </script>
        </div>
      </div>
    </main>
  </body>
</html>
